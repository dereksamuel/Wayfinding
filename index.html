<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Wayfinding</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, user-scalable=no">
	<!-- <meta name="viewport" content="width=device-width, initial-scale=1"> -->
	<link rel="stylesheet" href="styles/example.css">
	<script src="https://cdn.jsdelivr.net/npm/pinchzoom@0.8.3/build/pinchzoom.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js"
		integrity="sha512-aVKKRRi/Q/YV+4mjoKBsE4x3H+BkegoM/em46NNlCqNTmUYADjBbeNefNxYV7giUp0VxICtqdrbqU7iVaeZNXA=="
		crossorigin="anonymous" referrerpolicy="no-referrer"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"
		integrity="sha512-UXumZrZNiOwnTcZSHLOfcTs0aos2MzBWHXOHOuB0J/R44QB0dwY5JgfbvljXcklVf65Gc4El6RjZ+lnwd2az2g=="
		crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>

<body>
	<div id="content">
		<div id="myMaps">
		</div>
		<div id="controls">
			<label>Show</label>
			<button id="floor1">1st Floor</button>
			<button id="floor2">2nd Floor</button>
			<label for="beginSelect">Begin Route at</label>
			<select id="beginSelect">
				<option value="lcd.1">Reception</option>
				<option value="lobby">Lobby</option>
				<option value="R123">Conf Room</option>
			</select>
			<label for="endSelect">Show Route to</label>
			<select id="endSelect">
				<option></option>
				<option disabled="true">West 1st</option>
				<option value="R101">101</option>
				<option value="R102">102</option>
				<option value="R103">103</option>
				<option value="R104">104</option>
				<option disabled="true">East 1st</option>
				<option value="R111">111</option>
				<option value="R112">112</option>
				<option value="R113">113</option>
				<option value="R114">114</option>
				<option disabled="true">North 1st</option>
				<option value="R121">121</option>
				<option value="R122">122</option>
				<option value="R123">123</option>
				<option value="R124">124</option>
				<option value="R125">125</option>
				<option disabled="true">2nd</option>
				<option value="R201">201</option>
				<option value="R202">202</option>
				<option value="R203">203</option>
			</select>
			<label for="accessible">Accessible</label>
			<input id="accessible" type="checkbox" name="accessible" value="Accessible" />
		</div>
	</div>
	<div>
		<h1>Wayfinding Demo - version 3.3</h1>
		<p>Works with Chrome, Firefox, and Opera. IE will show path, but is not animating the path.</p>
		<!-- <p>For more information see <a
				href="https://github.com/ucdavis/wayfinding">https://github.com/ucdavis/wayfinding</a></p>
		<p>This is a demonstration of a wayfinding system for providing routing within a building. It allows the entire map
			data to be stored in a single .svg file from which it displays a map and extracts the information about which
			routes are available. A change in the .svg file will be enough to change routing results.</p>
		<p>The .svg files can be generated by Adobe Illustrator. Testing with Inkscape and other .svg programs will take
			place.</p>
		<h2>Things to try</h2>
		<ul>
			<li>Click any room and it will trigger the routing. We will be using this with a touch screen lcd at key points in
				our building.</li>
			<li>In addition to clicking on a room it is possible to trigger routing using the "Show Route to" dropdown or
				through JavaScript.</li>
			<li>Route to room 201 and try it with the Accessible option on and off an you will see that the accessible route
				takes the elevator rather than the stairs even though the path is longer. Accessible routing will be extended to
				allow certain path segments to be considered accessible or not.</li>
			<li>Change the "Begin Route at" selection and it will remember the last destination and reroute.</li>
			<li>Click the <a href="#" onClick="javascript:$('#myMaps').wayfinding('routeTo', 'R122');">second room from the
					left</a> on the top row on the first floor and note that it routes through the right hand side of the room
				next to it. The left hand side is set not to pass traffic. You can choose which routes to enable.</li>
			<li>
				<a href="#" onClick="javascript:$('#Paths line').attr('stroke-opacity', 1);">Show paths</a>.
				<a href="#" onClick="javascript:$('#Paths line').attr('stroke-opacity', 0);">Hide paths</a>.
				<a href="#" onClick="javascript:$('#Portals line').attr('stroke-opacity', 1);">Show portals</a>.
				<a href="#" onClick="javascript:$('#Portals line').attr('stroke-opacity', 0);">Hide portals</a>.
				<a href="#" onClick="javascript:$('#Doors line').attr('stroke-opacity', 1);">Show doors</a>.
				<a href="#" onClick="javascript:$('#Doors line').attr('stroke-opacity', 0);">Hide doors</a>.
			</li>
			<li>one way paths - work in progress</li>
			<li>portal lengths as route consideration - work in progress</li>
			<li>$('#myMaps').wayfinding('checkMap') make into clickable report into report div</li>
			<li>in addition to checkMap, add a dump parse, consider a load parse from JSON</li> -->
		</ul>
	</div>


	<script src="bower_components/jquery/dist/jquery.js"></script>
	<script src="src/jquery.wayfinding.js"></script>

	<script>
		const defaultMap = 'floor1';
		const maps = [
			{ 'path': 'test/fixtures/demo_map_1.svg', 'id': 'floor1' },
			{ 'path': 'test/fixtures/demo_map_2.svg', 'id': 'floor2' }
		]
		const floorIdsmap = new Array();
		$(document).ready(function () {
			$('#myMaps').wayfinding({
				maps,
				'path': {
					width: 2,
					color: '#000',
					radius: 8,
					speed: 8
				},
				'startpoint': function () {
					return 'lcd.1';
				},
				defaultMap,
				'showLocation': true
			}, function () {
				startZoom(defaultMap);
			});

			//make the floor buttons clickable
			$('#controls button').click(function () {
				console.log($(this).prop('id'));
				$('#myMaps').wayfinding('currentMap', $(this).prop('id'));
			});

			$('#controls #beginSelect').change(function () {
				$('#myMaps').wayfinding('startpoint', $(this).val());
				if ($('#endSelect').val() !== '') {
					$('#myMaps').wayfinding('routeTo', $('#endSelect').val());
				}
			});

			$('#controls #endSelect').change(function () {
				$('#myMaps').wayfinding('routeTo', $(this).val());
			});

			$('#controls #accessible').change(function () {
				if ($('#accessible:checked').val() !== undefined) {
					$('#myMaps').wayfinding('accessibleRoute', true);
				} else {
					$('#myMaps').wayfinding('accessibleRoute', false);
				}
				if ($('#endSelect').val() !== '') {
					$('#myMaps').wayfinding('routeTo', $('#endSelect').val());
				}
			});

			$('#myMaps').on('wayfinding:roomClicked', function (e, r) {
				$('#endSelect option[value="' + r.roomId + '"]').attr('selected', true);
			});
		});

		var startZoom = function (floorId) {
			if (floorIdsmap.find((item) => item === floorId)) {
				console.log("Id registered");
				return;
			}
			floorIdsmap.push(floorId);
			let svgElement = document.querySelector(`#${floorId} svg`);
			setTimeout(() => {
				svgElement.style["pointer-events"] = "all";
				svgElement.style["touch-action"] = "auto";
				svgElement.style["-webkit-user-drag"] = "initial";
				const elements = svgElement.querySelectorAll("[style='pointer-events: none;']");
				elements.forEach((item) => {
					item.style["pointer-events"] = "all";
				});
			}, 1000);
			//  Create Manager
			let mc = new Hammer.Manager(svgElement);
			function init() {
				// Create Recognizer
				const pinch = new Hammer.Pinch();
				const pan = new Hammer.Pan();

				pinch.requireFailure(pan);

				//  把 recognizer 加到 manager
				mc.add([pinch, pan]);

				mc.on("pinchstart", () => {
					console.log("pinchstart");
				});
				mc.on("pinchmove", zoom);
				mc.on("pinchend", pinchend);
				mc.on("panstart", panstart);
				mc.on("panmove", panmove);
				mc.on("panend", panend);

				//  回報滑鼠座標事件
				// svgElement.addEventListener('mousemove', reportCurrentPoint, false)
				//  拖曳的事件
				// svgElement.addEventListener('mousedown', mouseDown, false)
				// svgElement.addEventListener('mousemove', drag, false)
				// svgElement.addEventListener('mouseup', mouseUp, false)
				//  縮放的事件
				svgElement.addEventListener("wheel", zoom, false);
			}

			/*
			開始：滑鼠拖拉的效果
			*/
			let paning;
			let startViewBox = null;

			function panstart() {
				paning = true;
				console.log("panstart");
				//  1. 取得一開始的 viewBox 值，原本是字串，拆成陣列，方便之後運算
				startViewBox = svgElement
					.getAttribute("viewBox")
					.split(" ")
					.map(n => parseFloat(n));
			}
			//  拖拉的移動過程
			function panmove(e) {
				if (paning) {
					//  2. 取得 pointer 當前 viewport 中 client 座標值
					let startClient = {
						x: e.changedPointers[0].clientX,
						y: e.changedPointers[0].clientY
					};

					//  3. 計算對應回去的 SVG 座標值
					let newSVGPoint = svgElement.createSVGPoint();
					let CTM = svgElement.getScreenCTM();
					newSVGPoint.x = startClient.x;
					newSVGPoint.y = startClient.y;
					let startSVGPoint = newSVGPoint.matrixTransform(CTM.inverse());

					//  4. 計算拖曳後滑鼠所在的 viewport client 座標值
					let moveToClient = {
						x: e.changedPointers[0].clientX + e.deltaX,
						y: e.changedPointers[0].clientY + e.deltaY
					};

					//  5. 計算對應回去的 SVG 座標值
					newSVGPoint = svgElement.createSVGPoint();
					CTM = svgElement.getScreenCTM();
					newSVGPoint.x = moveToClient.x;
					newSVGPoint.y = moveToClient.y;
					let moveToSVGPoint = newSVGPoint.matrixTransform(CTM.inverse());

					// 6. 計算位移量
					let delta = {
						dx: startSVGPoint.x - moveToSVGPoint.x,
						dy: startSVGPoint.y - moveToSVGPoint.y
					};
					//  7. 設定新的 viewBox 值
					let moveToViewBox = `${startViewBox[0] + delta.dx} ${startViewBox[1] + delta.dy} ${startViewBox[2]} ${startViewBox[3]}`;
					svgElement.setAttribute("viewBox", moveToViewBox);
				}
			}

			//  滑鼠點擊結束（拖曳結束）
			function panend() {
				console.log("panend");
				paning = false;
			}
			//  結束：滑鼠拖拉的效果

			/*
			開始：滑鼠縮放的效果
			*/
			let adjustScale = 1;
			let currentScale = null;
			let ratio = 1;

			function zoom(e) {
				//  1.取得一開始的 viewBox。
				let startViewBox = svgElement
					.getAttribute("viewBox")
					.split(" ")
					.map(n => parseFloat(n));

				//  2.取得滑鼠執行縮放位置的 viewPort Client 座標，並利用 CTM 對應取得 SVG 座標。

				//  2.1 取得滑鼠執行縮放的位置
				let startClient;
				if (e.type === "wheel") {
					startClient = {
						x: e.clientX,
						y: e.clientY
					};
				}
				if (e.type === "pinchmove") {
					startClient = {
						x: e.center.x,
						y: e.center.y
					};
				}

				//  2.2 轉換成 SVG 座標系統中的 SVG 座標點
				let newSVGPoint = svgElement.createSVGPoint();
				let CTM = svgElement.getScreenCTM();
				newSVGPoint.x = startClient.x;
				newSVGPoint.y = startClient.y;
				let startSVGPoint = newSVGPoint.matrixTransform(CTM.inverse());

				//  3.進行縮放，如果要讓原本的尺寸縮放兩倍的話。
				//  3.1 設定縮放倍率
				let zoomSize = {
					max: 2,
					min: 0.5
				};

				let viewport = {
					width: svgElement.getBoundingClientRect().width,
					height: svgElement.getBoundingClientRect().height
				};

				if (e.type === "wheel") {
					let tmp = ratio + e.deltaY / 100;
					console.log('tmp', tmp)
					if (tmp >= zoomSize.max) {
						tmp = zoomSize.max;
					}
					if (tmp <= zoomSize.min) {
						tmp = zoomSize.min;
					}
					ratio = tmp;
				}

				if (e.type === "pinchmove") {
					currentScale = adjustScale * e.scale;
					ratio = 1 / currentScale;

					if (ratio >= zoomSize.max) {
						ratio = zoomSize.max;
						currentScale = 1 / zoomSize.max;
					}

					if (ratio <= zoomSize.min) {
						ratio = zoomSize.min;
						currentScale = 1 / zoomSize.min;
					}
				}

				//  3.2 進行縮放

				svgElement.setAttribute(
					"viewBox",
					`${startViewBox[0]} ${startViewBox[1]} ${viewport.width * ratio} ${viewport.height * ratio}`
				);

				//  4.將一開始滑鼠的執行縮放位置的 viewPort Client 座標利用新的 CTM ，轉換出對應的 SVG 座標。
				CTM = svgElement.getScreenCTM();
				let moveToSVGPoint = newSVGPoint.matrixTransform(CTM.inverse());

				//  5.取得在縮放過程中該圓點的位移量 `(svgElementX0 - svgElementX1)`。
				let delta = {
					dx: startSVGPoint.x - moveToSVGPoint.x,
					dy: startSVGPoint.y - moveToSVGPoint.y
				};

				//  6.設定最終的 viewBox2
				let middleViewBox = svgElement
					.getAttribute("viewBox")
					.split(" ")
					.map(n => parseFloat(n));
				let moveBackViewBox = `${middleViewBox[0] + delta.dx} ${middleViewBox[1] + delta.dy} ${middleViewBox[2]} ${middleViewBox[3]}`;
				svgElement.setAttribute("viewBox", moveBackViewBox);
			}

			function pinchend(e) {
				adjustScale = currentScale;
				mc.off("pan");
				setTimeout(mc.on("pan"), 100);
				console.log("pinchend");
			}

			init();
		}
	</script>
</body>

</html>